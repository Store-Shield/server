package com.example.quantiztest;

import android.util.Log;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class SimpleTracker {
    private static final String TAG = "SimpleTracker";
    private static final float IOU_THRESHOLD = 0.25f;  // 같은 객체로 간주할 IoU 임계값
    private static final int MAX_AGE = 30;  // 객체가 사라졌다고 판단하기 전 최대 프레임 수 (교차 상황을 위해 증가)
    
    // 모션 예측 강화
    private static final boolean USE_VELOCITY_PREDICTION = true;
    private static final float VELOCITY_WEIGHT = 0.6f;
    
    // 궤적 일관성 관련 
    private static final int TRAJECTORY_HISTORY_SIZE = 20;  // 궤적 기록 유지 프레임 수
    private static final float TRAJECTORY_SIMILARITY_THRESHOLD = 0.6f;  // 궤적 유사성 임계값
    
    // 추적 중인 객체 목록
    private final Map<Integer, TrackedObject> trackedObjects = new HashMap<>();
    private int nextId = 0;
    
    // 최근에 사라진 객체 캐시 (재등장 식별용)
    private final Map<Integer, TrackedObject> recentlyDisappeared = new HashMap<>();
    private static final int MAX_DISAPPEAR_AGE = 100;  // 재등장 식별을 위한 최대 사라진 프레임 수

    /**
     * 현재 프레임에서 탐지된 객체를 이전 프레임의 추적 객체와 연결
     * @param detections 현재 프레임에서 탐지된 객체 목록
     * @return 추적 ID가 할당된 객체 목록
     */
    public List<TrackedObject> update(List<YoloImageProcessor.Detection> detections) {
        // 모든 추적 객체 예측 단계
        for (TrackedObject obj : trackedObjects.values()) {
            obj.predict();
        }
        
        // 빈 탐지 목록이면 모든 추적 객체의 나이를 증가시키고 반환
        if (detections == null || detections.isEmpty()) {
            increaseAge();
            updateDisappearedObjects();
            removeOldObjects();
            return new ArrayList<>(trackedObjects.values());
        }

        // 현재 프레임에서 탐지된 객체에 일치하는 추적 객체 찾기
        boolean[] matched = new boolean[detections.size()];
        
        // 1단계: 높은 IoU 매칭 (같은 위치에 있는 객체)
        performIoUMatching(detections, matched);
        
        // 2단계: 궤적 기반 매칭 (교차 상황에서 중요)
        performTrajectoryMatching(detections, matched);
        
        // 3단계: 사라졌다가 다시 나타난 객체 매칭
        performReappearanceMatching(detections, matched);
        
        // 매칭되지 않은 추적 객체의 나이 증가
        for (TrackedObject obj : trackedObjects.values()) {
            if (obj.getLastMatchedTime() == 0) {
                obj.incrementAge();
            }
        }
        
        // 매칭되지 않은 새 객체 추가
        for (int i = 0; i < detections.size(); i++) {
            if (!matched[i]) {
                YoloImageProcessor.Detection detection = detections.get(i);
                TrackedObject newTrackedObj = new TrackedObject(
                    nextId++,
                    detection.getLabel(),
                    detection.getConfidence(),
                    detection.getLeft(),
                    detection.getTop(),
                    detection.getRight(),
                    detection.getBottom()
                );
                trackedObjects.put(newTrackedObj.getId(), newTrackedObj);
            }
        }

        // 오래된 객체 처리 (완전히 제거하지 않고 최근 사라진 객체 캐시로 이동)
        updateDisappearedObjects();
        
        // 현재 추적 중인 객체 목록 반환
        return new ArrayList<>(trackedObjects.values());
    }
    
    /**
     * IoU 기반 매칭 수행
     */
    private void performIoUMatching(List<YoloImageProcessor.Detection> detections, boolean[] matched) {
        // 매칭 점수 행렬 계산
        Map<Integer, int[]> bestMatches = new HashMap<>();  // <추적 객체 ID, [최적 탐지 인덱스, 매칭 우선순위]>
        Map<Integer, Float> bestScores = new HashMap<>();  // <추적 객체 ID, 최고 IoU 점수>
        
        // 모든 가능한 매칭 쌍의 IoU 계산 및 정렬
        for (TrackedObject trackedObj : trackedObjects.values()) {
            int bestDetectionIdx = -1;
            float bestIoU = IOU_THRESHOLD;
            
            for (int i = 0; i < detections.size(); i++) {
                if (matched[i]) continue;  // 이미 매칭된 탐지 건너뛰기
                
                YoloImageProcessor.Detection detection = detections.get(i);
                
                // 라벨이 같은 객체만 비교
                if (!trackedObj.getLabel().equals(detection.getLabel())) continue;
                
                float iou = calculateIoU(trackedObj, detection);
                
                if (iou > bestIoU) {
                    bestIoU = iou;
                    bestDetectionIdx = i;
                }
            }
            
            if (bestDetectionIdx >= 0) {
                bestMatches.put(trackedObj.getId(), new int[]{bestDetectionIdx, trackedObj.getAge()});
                bestScores.put(trackedObj.getId(), bestIoU);
            }
        }
        
        // 매칭 충돌 해결 (나이가 많은 추적 객체 우선)
        List<Integer> trackedIds = new ArrayList<>(bestMatches.keySet());
        
        // 나이 기준 내림차순 정렬 (나이가 많은(오래 추적된) 객체 우선)
        trackedIds.sort((id1, id2) -> {
            int[] match1 = bestMatches.get(id1);
            int[] match2 = bestMatches.get(id2);
            // 우선순위(나이) 기준 내림차순
            return Integer.compare(match2[1], match1[1]);
        });
        
        // 매칭 적용
        for (int trackedId : trackedIds) {
            int[] match = bestMatches.get(trackedId);
            int detectionIdx = match[0];
            
            // 이미 매칭됐는지 확인
            if (matched[detectionIdx]) continue;
            
            // 매칭 수행
            TrackedObject trackedObj = trackedObjects.get(trackedId);
            YoloImageProcessor.Detection matchedDetection = detections.get(detectionIdx);
            
            trackedObj.update(matchedDetection);
            matched[detectionIdx] = true;
            
            Log.d(TAG, "IoU 매칭: 객체 ID=" + trackedId + 
                  " -> 탐지 #" + detectionIdx + 
                  " (IoU=" + String.format("%.2f", bestScores.get(trackedId)) + ")");
        }
    }
    
    /**
     * 궤적 기반 매칭 수행 (교차 상황에서 중요)
     */
    private void performTrajectoryMatching(List<YoloImageProcessor.Detection> detections, boolean[] matched) {
        // 충분한 궤적 기록이 있는 객체만 처리
        List<TrackedObject> trackedWithHistory = new ArrayList<>();
        
        for (TrackedObject obj : trackedObjects.values()) {
            if (obj.getLastMatchedTime() == 0 && obj.getTrajectorySize() >= 3) {
                trackedWithHistory.add(obj);
            }
        }
        
        // 궤적 기록이 없으면 종료
        if (trackedWithHistory.isEmpty()) return;
        
        // 각 미매칭 추적 객체에 대해 궤적 기반 매칭 시도
        for (TrackedObject trackedObj : trackedWithHistory) {
            int bestDetectionIdx = -1;
            float bestSimilarity = TRAJECTORY_SIMILARITY_THRESHOLD;
            
            for (int i = 0; i < detections.size(); i++) {
                if (matched[i]) continue;  // 이미 매칭된 탐지 건너뛰기
                
                YoloImageProcessor.Detection detection = detections.get(i);
                
                // 라벨이 같은 객체만 비교
                if (!trackedObj.getLabel().equals(detection.getLabel())) continue;
                
                // 궤적 유사성 계산
                float similarity = calculateTrajectorySimilarity(trackedObj, detection);
                
                if (similarity > bestSimilarity) {
                    bestSimilarity = similarity;
                    bestDetectionIdx = i;
                }
            }
            
            if (bestDetectionIdx >= 0) {
                YoloImageProcessor.Detection matchedDetection = detections.get(bestDetectionIdx);
                trackedObj.update(matchedDetection);
                matched[bestDetectionIdx] = true;
                
                Log.d(TAG, "궤적 매칭: 객체 ID=" + trackedObj.getId() + 
                      " -> 탐지 #" + bestDetectionIdx + 
                      " (유사도=" + String.format("%.2f", bestSimilarity) + ")");
            }
        }
    }
    
    /**
     * 사라졌다가 다시 나타난 객체 매칭
     */
    private void performReappearanceMatching(List<YoloImageProcessor.Detection> detections, boolean[] matched) {
        if (recentlyDisappeared.isEmpty()) return;
        
        // 각 미매칭 탐지에 대해 최근 사라진 객체와 매칭 시도
        for (int i = 0; i < detections.size(); i++) {
            if (matched[i]) continue;
            
            YoloImageProcessor.Detection detection = detections.get(i);
            TrackedObject bestMatch = null;
            float bestScore = 0.65f;  // 재등장 매칭 임계값 (높게 설정하여 오류 방지)
            
            for (TrackedObject disappearedObj : recentlyDisappeared.values()) {
                // 라벨이 같은 객체만 비교
                if (!disappearedObj.getLabel().equals(detection.getLabel())) continue;
                
                // 외형 및 예상 위치 유사성 계산
                float score = calculateReappearanceScore(disappearedObj, detection);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = disappearedObj;
                }
            }
            
            if (bestMatch != null) {
                // 사라진 객체를 현재 탐지와 매칭하고 활성 객체로 복원
                bestMatch.update(detection);
                bestMatch.resetAge();  // 나이 초기화
                
                trackedObjects.put(bestMatch.getId(), bestMatch);
                recentlyDisappeared.remove(bestMatch.getId());
                
                matched[i] = true;
                
                Log.d(TAG, "재등장 매칭: 객체 ID=" + bestMatch.getId() + 
                      " -> 탐지 #" + i + 
                      " (유사도=" + String.format("%.2f", bestScore) + ")");
            }
        }
    }
    
    /**
     * 궤적 유사성 계산
     */
    private float calculateTrajectorySimilarity(TrackedObject trackedObj, YoloImageProcessor.Detection detection) {
        if (trackedObj.getTrajectorySize() < 3) return 0;
        
        // 추적 객체의 이동 방향 및 속도 계산
        List<Point> trajectory = trackedObj.getTrajectory();
        
        Point p1 = trajectory.get(trajectory.size() - 3);
        Point p2 = trajectory.get(trajectory.size() - 2);
        Point p3 = trajectory.get(trajectory.size() - 1);
        
        // 이동 벡터 계산
        float vx1 = p2.x - p1.x;
        float vy1 = p2.y - p1.y;
        float vx2 = p3.x - p2.x;
        float vy2 = p3.y - p2.y;
        
        // 평균 이동 벡터
        float avgVx = (vx1 + vx2) / 2;
        float avgVy = (vy1 + vy2) / 2;
        
        // 예측 위치 계산
        float predictedX = p3.x + avgVx;
        float predictedY = p3.y + avgVy;
        
        // 탐지된 객체의 중심 좌표
        float detCenterX = (detection.getLeft() + detection.getRight()) / 2;
        float detCenterY = (detection.getTop() + detection.getBottom()) / 2;
        
        // 예측 위치와 탐지 위치 사이의 거리
        float distance = (float) Math.sqrt(
                Math.pow(predictedX - detCenterX, 2) + 
                Math.pow(predictedY - detCenterY, 2));
        
        // 객체 크기 기준 정규화
        float objSize = Math.max(
                detection.getRight() - detection.getLeft(),
                detection.getBottom() - detection.getTop());
        
        float normalizedDistance = Math.max(0, 1 - distance / (2 * objSize));
        
        // 크기 유사성
        float trackedWidth = trackedObj.getRight() - trackedObj.getLeft();
        float trackedHeight = trackedObj.getBottom() - trackedObj.getTop();
        float detWidth = detection.getRight() - detection.getLeft();
        float detHeight = detection.getBottom() - detection.getTop();
        
        float sizeRatio = Math.min(trackedWidth / detWidth, detWidth / trackedWidth) *
                          Math.min(trackedHeight / detHeight, detHeight / trackedHeight);
        
        // 종합 점수 (위치 예측 + 크기 유사성)
        return 0.7f * normalizedDistance + 0.3f * sizeRatio;
    }
    
    /**
     * 재등장 점수 계산
     */
    private float calculateReappearanceScore(TrackedObject disappearedObj, YoloImageProcessor.Detection detection) {
        // 예측된 위치 (사라진 객체의 마지막 위치 + 속도 예측)
        float predictedCenterX = (disappearedObj.getLeft() + disappearedObj.getRight()) / 2 + 
                                disappearedObj.getVelocityX() * disappearedObj.getAge();
        float predictedCenterY = (disappearedObj.getTop() + disappearedObj.getBottom()) / 2 + 
                                disappearedObj.getVelocityY() * disappearedObj.getAge();
        
        // 탐지된 객체의 중심 좌표
        float detCenterX = (detection.getLeft() + detection.getRight()) / 2;
        float detCenterY = (detection.getTop() + detection.getBottom()) / 2;
        
        // 예측 위치와 탐지 위치 사이의 거리
        float distance = (float) Math.sqrt(
                Math.pow(predictedCenterX - detCenterX, 2) + 
                Math.pow(predictedCenterY - detCenterY, 2));
        
        // 객체 크기 기준 정규화
        float objSize = Math.max(
                disappearedObj.getRight() - disappearedObj.getLeft(),
                disappearedObj.getBottom() - disappearedObj.getTop());
        
        float normalizedDistance = Math.max(0, 1 - distance / (5 * objSize));  // 넓은 거리 허용
        
        // 크기 유사성
        float trackedWidth = disappearedObj.getRight() - disappearedObj.getLeft();
        float trackedHeight = disappearedObj.getBottom() - disappearedObj.getTop();
        float detWidth = detection.getRight() - detection.getLeft();
        float detHeight = detection.getBottom() - detection.getTop();
        
        float sizeRatio = Math.min(trackedWidth / detWidth, detWidth / trackedWidth) *
                         Math.min(trackedHeight / detHeight, detHeight / trackedHeight);
        
        // 재등장 점수 (시간 가중치 포함)
        float timeWeight = Math.max(0, 1 - (float)disappearedObj.getAge() / MAX_DISAPPEAR_AGE);
        
        return (0.5f * normalizedDistance + 0.3f * sizeRatio) * timeWeight;
    }
    
    /**
     * 모든 추적 객체의 나이를 증가시킴
     */
    private void increaseAge() {
        for (TrackedObject obj : trackedObjects.values()) {
            obj.incrementAge();
        }
    }
    
    /**
     * 사라진 객체 관리
     */
    private void updateDisappearedObjects() {
        // 현재 추적 객체 중 나이가 많은 객체를 사라진 객체 목록으로 이동
        Iterator<Map.Entry<Integer, TrackedObject>> it = trackedObjects.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<Integer, TrackedObject> entry = it.next();
            TrackedObject obj = entry.getValue();
            
            if (obj.getAge() > MAX_AGE) {
                Log.d(TAG, "객체 사라짐 (캐시로 이동): ID=" + obj.getId() + 
                           ", Label=" + obj.getLabel() + 
                           ", Age=" + obj.getAge());
                
                recentlyDisappeared.put(obj.getId(), obj);
                it.remove();
            }
        }
        
        // 오래된 사라진 객체 제거
        it = recentlyDisappeared.entrySet().iterator();
        while (it.hasNext()) {
            TrackedObject obj = it.next().getValue();
            obj.incrementAge();
            
            if (obj.getAge() > MAX_DISAPPEAR_AGE) {
                Log.d(TAG, "사라진 객체 최종 제거: ID=" + obj.getId() + 
                           ", Label=" + obj.getLabel() + 
                           ", Age=" + obj.getAge());
                it.remove();
            }
        }
    }
    
    /**
     * 오래된 객체 제거 - 사용하지 않음 (updateDisappearedObjects로 대체)
     */
    private void removeOldObjects() {
        // 대신 updateDisappearedObjects 메서드 사용
    }

    /**
     * 두 객체 간의 IoU(Intersection over Union)를 계산
     */
    private float calculateIoU(TrackedObject trackedObj, YoloImageProcessor.Detection detection) {
        // 교차 영역 계산
        float xLeft = Math.max(trackedObj.getLeft(), detection.getLeft());
        float yTop = Math.max(trackedObj.getTop(), detection.getTop());
        float xRight = Math.min(trackedObj.getRight(), detection.getRight());
        float yBottom = Math.min(trackedObj.getBottom(), detection.getBottom());

        // 교차 영역이 없으면 0 반환
        if (xRight < xLeft || yBottom < yTop) return 0;

        float intersectionArea = (xRight - xLeft) * (yBottom - yTop);

        // 각 영역 계산
        float trackedObjArea = (trackedObj.getRight() - trackedObj.getLeft()) *
                (trackedObj.getBottom() - trackedObj.getTop());
        float detectionArea = (detection.getRight() - detection.getLeft()) *
                (detection.getBottom() - detection.getTop());

        // IoU 계산
        return intersectionArea / (trackedObjArea + detectionArea - intersectionArea);
    }
    
    /**
     * 2D 좌표 포인트 클래스
     */
    private static class Point {
        public float x;
        public float y;
        
        public Point(float x, float y) {
            this.x = x;
            this.y = y;
        }
    }

    /**
     * 추적 객체 클래스 - 교차 상황에서 ID 유지를 위한 개선
     */
    public static class TrackedObject {
        private final int id;
        private String label;
        private float confidence;
        private float left;
        private float top;
        private float right;
        private float bottom;
        private int age;
        private int totalVisibleCount;  // 총 보인 프레임 수

        // 속도 추적을 위한 필드
        private float velocityX;
        private float velocityY;
        private long lastMatchedTime;
        
        // 궤적 기록 
        private final LinkedList<Point> trajectory;

        public TrackedObject(int id, String label, float confidence,
                            float left, float top, float right, float bottom) {
            this.id = id;
            this.label = label;
            this.confidence = confidence;
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
            this.age = 0;
            this.totalVisibleCount = 1;
            this.lastMatchedTime = System.currentTimeMillis();
            
            this.velocityX = 0;
            this.velocityY = 0;
            
            // 궤적 기록 초기화
            this.trajectory = new LinkedList<>();
            this.trajectory.add(new Point((left + right) / 2, (top + bottom) / 2));
        }

        /**
         * 새로운 탐지 결과로 추적 객체 업데이트
         */
        public void update(YoloImageProcessor.Detection detection) {
            float centerX = (detection.getLeft() + detection.getRight()) / 2;
            float centerY = (detection.getTop() + detection.getBottom()) / 2;
            
            // 이전 중심점
            float prevCenterX = (left + right) / 2;
            float prevCenterY = (top + bottom) / 2;
            
            // 속도 업데이트 (이동 평균 사용)
            velocityX = VELOCITY_WEIGHT * (centerX - prevCenterX) + (1 - VELOCITY_WEIGHT) * velocityX;
            velocityY = VELOCITY_WEIGHT * (centerY - prevCenterY) + (1 - VELOCITY_WEIGHT) * velocityY;

            // 객체 상태 업데이트
            this.confidence = detection.getConfidence();
            this.left = detection.getLeft();
            this.top = detection.getTop();
            this.right = detection.getRight();
            this.bottom = detection.getBottom();
            
            // 궤적 기록 업데이트
            this.trajectory.add(new Point(centerX, centerY));
            while (this.trajectory.size() > TRAJECTORY_HISTORY_SIZE) {
                this.trajectory.removeFirst();
            }

            // 나이 초기화 및 매칭 시간 업데이트
            this.age = 0;
            this.totalVisibleCount++;
            this.lastMatchedTime = System.currentTimeMillis();
        }
        
        /**
         * 나이 초기화
         */
        public void resetAge() {
            this.age = 0;
        }

        public void incrementAge() {
            this.age++;
        }

        /**
         * 모션 모델 기반 위치 예측
         */
        public void predict() {
            if (age > 0 && USE_VELOCITY_PREDICTION) {
                float width = right - left;
                float height = bottom - top;
                
                // 현재 중심점
                float centerX = (left + right) / 2;
                float centerY = (top + bottom) / 2;
                
                // 예측된 중심점
                float predictedX = centerX + velocityX;
                float predictedY = centerY + velocityY;
                
                // 위치 업데이트
                left = predictedX - width / 2;
                top = predictedY - height / 2;
                right = predictedX + width / 2;
                bottom = predictedY + height / 2;
                
                // 궤적 업데이트 (예측 위치)
                if (age == 1) {  // 첫 번째 예측에서만 궤적 추가
                    trajectory.add(new Point(predictedX, predictedY));
                    while (trajectory.size() > TRAJECTORY_HISTORY_SIZE) {
                        trajectory.removeFirst();
                    }
                }
            }
        }

        // Getters
        public int getId() { return id; }
        public String getLabel() { return label; }
        public float getConfidence() { return confidence; }
        public float getLeft() { return left; }
        public float getTop() { return top; }
        public float getRight() { return right; }
        public float getBottom() { return bottom; }
        public int getAge() { return age; }
        public int getTotalVisibleCount() { return totalVisibleCount; }
        public long getLastMatchedTime() { return lastMatchedTime; }
        public float getVelocityX() { return velocityX; }
        public float getVelocityY() { return velocityY; }
        public List<Point> getTrajectory() { return trajectory; }
        public int getTrajectorySize() { return trajectory.size(); }
        
        @Override
        public String toString() {
            return id + ": " + label + " (" + String.format("%.2f", confidence * 100) + 
                   "%), age=" + age + ", visible=" + totalVisibleCount;
        }
    }
}