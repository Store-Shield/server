package com.example.quantiztest;

import android.util.Log;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class SimpleTracker {
    private static final String TAG = "SimpleTracker";
    private static final float IOU_THRESHOLD = 0.25f;  // 같은 객체로 간주할 IoU 임계값 낮출수록 잘 추정
    private static final int MAX_AGE = 15;  // 객체가 사라졌다고 판단하기 전 최대 프레임 수 증가
    
    // 모션 모델 강화
    private static final boolean USE_VELOCITY_PREDICTION = true;
    private static final float VELOCITY_WEIGHT = 0.6f;
    private static final float ACCELERATION_WEIGHT = 0.3f;
    
    // 외형 모델 및 매칭 가중치
    private static final float APPEARANCE_WEIGHT = 0.4f;
    private static final float MOTION_WEIGHT = 0.3f;
    private static final float IOU_WEIGHT = 0.3f;
    
    // 추적 히스토리 관련
    private static final int MAX_HISTORY_LENGTH = 10;
    
    // 추적 중인 객체 목록
    private final Map<Integer, TrackedObject> trackedObjects = new HashMap<>();
    private int nextId = 0;
    
    // 딥솔트(DeepSORT) 관련 매개변수
    private static final float MIN_CONFIDENCE = 0.3f;
    private static final float DETECTION_THRESHOLD = 0.3f;
    private static final int MIN_HITS = 3;
    private static final boolean USE_KALMAN_FILTER = true;

    /**
     * 현재 프레임에서 탐지된 객체를 이전 프레임의 추적 객체와 연결
     * @param detections 현재 프레임에서 탐지된 객체 목록
     * @return 추적 ID가 할당된 객체 목록
     */
    public List<TrackedObject> update(List<YoloImageProcessor.Detection> detections) {
        // 모든 추적 객체에 대해 모션 예측 수행
        predictAllTrackedObjects();
        
        // 빈 탐지 목록이면 모든 추적 객체의 나이를 증가시키고 반환
        if (detections == null || detections.isEmpty()) {
            increaseAge();
            removeOldObjects();
            return new ArrayList<>(trackedObjects.values());
        }

        // 현재 프레임에서 탐지된 객체에 일치하는 추적 객체 찾기
        boolean[] matched = new boolean[detections.size()];
        
        // 매칭 점수 행렬 계산
        float[][] matchingScores = calculateMatchingScores(detections);

        // 1단계: 높은 확신도로 매칭 (외형 + 모션 + IoU)
        matchDetectionsWithHighConfidence(detections, matched, matchingScores);

        // 2단계: 히스토리 기반 매칭 (교차 상황에서 특히 효과적)
        matchDetectionsWithHistory(detections, matched);
        
        // 3단계: 남은 객체 매칭
        matchRemainingDetections(detections, matched, matchingScores);

        // 매칭되지 않은 새 객체 추가
        addNewDetections(detections, matched);

        // 오래된 객체 제거
        removeOldObjects();

        // 현재 추적 중인 객체 목록 반환
        return new ArrayList<>(trackedObjects.values());
    }
    
    /**
     * 모든 추적 객체에 대해 모션 예측 수행
     */
    private void predictAllTrackedObjects() {
        for (TrackedObject trackedObj : trackedObjects.values()) {
            trackedObj.predict();
        }
    }
    
    /**
     * 추적 객체와 탐지 객체 간의 매칭 점수 행렬 계산
     */
    private float[][] calculateMatchingScores(List<YoloImageProcessor.Detection> detections) {
        float[][] scores = new float[trackedObjects.size()][detections.size()];
        
        int i = 0;
        for (TrackedObject trackedObj : trackedObjects.values()) {
            int j = 0;
            for (YoloImageProcessor.Detection detection : detections) {
                // 라벨이 다르면 낮은 점수 할당
                if (!trackedObj.getLabel().equals(detection.getLabel())) {
                    scores[i][j] = -1.0f;
                    j++;
                    continue;
                }
                
                // IoU 계산
                float iou = calculateIoU(trackedObj, detection);
                
                // 모션 일관성 점수 계산
                float motionScore = calculateMotionConsistency(trackedObj, detection);
                
                // 외형 유사성 점수 계산
                float appearanceScore = calculateAppearanceSimilarity(trackedObj, detection);
                
                // 종합 점수 계산
                scores[i][j] = IOU_WEIGHT * iou + 
                               MOTION_WEIGHT * motionScore + 
                               APPEARANCE_WEIGHT * appearanceScore;
                
                j++;
            }
            i++;
        }
        
        return scores;
    }
    
    /**
     * 모션 일관성 점수 계산
     */
    private float calculateMotionConsistency(TrackedObject trackedObj, YoloImageProcessor.Detection detection) {
        float trackedCenterX = (trackedObj.getLeft() + trackedObj.getRight()) / 2;
        float trackedCenterY = (trackedObj.getTop() + trackedObj.getBottom()) / 2;
        
        float detCenterX = (detection.getLeft() + detection.getRight()) / 2;
        float detCenterY = (detection.getTop() + detection.getBottom()) / 2;
        
        // 예측된 위치와 실제 탐지 위치 간의 거리
        float distanceX = Math.abs(trackedCenterX - detCenterX);
        float distanceY = Math.abs(trackedCenterY - detCenterY);
        
        // 정규화된 거리 계산
        float trackedWidth = trackedObj.getRight() - trackedObj.getLeft();
        float trackedHeight = trackedObj.getBottom() - trackedObj.getTop();
        float maxDim = Math.max(trackedWidth, trackedHeight);
        
        float normalizedDistance = (float) Math.sqrt(distanceX * distanceX + distanceY * distanceY) / maxDim;
        
        // 정규화된 거리를 점수로 변환 (거리가 작을수록 높은 점수)
        return Math.max(0, 1.0f - normalizedDistance);
    }
    
    /**
     * 외형 유사성 점수 계산
     */
    private float calculateAppearanceSimilarity(TrackedObject trackedObj, YoloImageProcessor.Detection detection) {
        // 크기 유사성
        float trackedWidth = trackedObj.getRight() - trackedObj.getLeft();
        float trackedHeight = trackedObj.getBottom() - trackedObj.getTop();
        
        float detWidth = detection.getRight() - detection.getLeft();
        float detHeight = detection.getBottom() - detection.getTop();
        
        float widthRatio = Math.min(trackedWidth, detWidth) / Math.max(trackedWidth, detWidth);
        float heightRatio = Math.min(trackedHeight, detHeight) / Math.max(trackedHeight, detHeight);
        
        float sizeScore = (widthRatio + heightRatio) / 2.0f;
        
        // 색상 정보나 딥 특성이 있다면 여기서 비교할 수 있음
        // 현재는 미구현 상태로 가정하고, 크기 유사성만 사용
        
        // 신뢰도 유사성
        float confidenceScore = Math.min(trackedObj.getConfidence(), detection.getConfidence()) / 
                                Math.max(trackedObj.getConfidence(), detection.getConfidence());
        
        return 0.7f * sizeScore + 0.3f * confidenceScore;
    }
    
    /**
     * 높은 확신도로 객체 매칭
     */
    private void matchDetectionsWithHighConfidence(List<YoloImageProcessor.Detection> detections, 
                                                  boolean[] matched, 
                                                  float[][] matchingScores) {
        float highConfidenceThreshold = 0.7f;
        
        List<TrackedObject> trackedList = new ArrayList<>(trackedObjects.values());
        
        // 각 추적 객체에 대해 최적의 매칭 찾기
        for (int i = 0; i < trackedList.size(); i++) {
            TrackedObject trackedObj = trackedList.get(i);
            int bestMatchIdx = -1;
            float bestScore = highConfidenceThreshold;
            
            for (int j = 0; j < detections.size(); j++) {
                if (matched[j]) continue;
                
                if (matchingScores[i][j] > bestScore) {
                    bestScore = matchingScores[i][j];
                    bestMatchIdx = j;
                }
            }
            
            if (bestMatchIdx >= 0) {
                YoloImageProcessor.Detection matchedDetection = detections.get(bestMatchIdx);
                trackedObj.update(matchedDetection);
                matched[bestMatchIdx] = true;
            }
        }
    }
    
    /**
     * 히스토리 기반 매칭 (교차 상황에서 특히 중요)
     */
    private void matchDetectionsWithHistory(List<YoloImageProcessor.Detection> detections, boolean[] matched) {
        List<TrackedObject> trackedList = new ArrayList<>(trackedObjects.values());
        
        // 매칭되지 않은 추적 객체 중 히스토리가 충분한 객체만 처리
        for (TrackedObject trackedObj : trackedList) {
            if (trackedObj.getLastMatchedTime() == 0 || 
                trackedObj.getHistoryLength() < MIN_HITS) continue;
            
            int bestMatchIdx = -1;
            float bestHistoryScore = 0.4f;  // 히스토리 기반 매칭 임계값
            
            for (int i = 0; i < detections.size(); i++) {
                if (matched[i]) continue;
                
                YoloImageProcessor.Detection detection = detections.get(i);
                if (!trackedObj.getLabel().equals(detection.getLabel())) continue;
                
                // 히스토리 기반 매칭 점수 계산
                float historyScore = calculateHistoryMatchScore(trackedObj, detection);
                
                if (historyScore > bestHistoryScore) {
                    bestHistoryScore = historyScore;
                    bestMatchIdx = i;
                }
            }
            
            if (bestMatchIdx >= 0) {
                YoloImageProcessor.Detection matchedDetection = detections.get(bestMatchIdx);
                trackedObj.update(matchedDetection);
                matched[bestMatchIdx] = true;
            }
        }
    }
    
    /**
     * 히스토리 기반 매칭 점수 계산
     */
    private float calculateHistoryMatchScore(TrackedObject trackedObj, YoloImageProcessor.Detection detection) {
        // 현재 궤적과의 일관성 검사
        float centerX = (detection.getLeft() + detection.getRight()) / 2;
        float centerY = (detection.getTop() + detection.getBottom()) / 2;
        
        List<float[]> positionHistory = trackedObj.getPositionHistory();
        if (positionHistory.size() < 2) return 0;
        
        // 최근 위치로부터의 이동 벡터 계산
        float[] lastPos = positionHistory.get(positionHistory.size() - 1);
        float[] prevPos = positionHistory.get(positionHistory.size() - 2);
        
        float expectedVelocityX = lastPos[0] - prevPos[0];
        float expectedVelocityY = lastPos[1] - prevPos[1];
        
        // 예상 위치 계산
        float expectedX = lastPos[0] + expectedVelocityX;
        float expectedY = lastPos[1] + expectedVelocityY;
        
        // 실제 위치와 예상 위치 간의 차이
        float distanceError = (float) Math.sqrt(
            Math.pow(expectedX - centerX, 2) + 
            Math.pow(expectedY - centerY, 2)
        );
        
        // 객체 크기에 따른 정규화
        float size = Math.max(
            detection.getRight() - detection.getLeft(),
            detection.getBottom() - detection.getTop()
        );
        
        float normalizedError = distanceError / size;
        
        // 정규화된 오차를 점수로 변환
        return Math.max(0, 1.0f - normalizedError);
    }
    
    /**
     * 남은 객체 매칭
     */
    private void matchRemainingDetections(List<YoloImageProcessor.Detection> detections, 
                                         boolean[] matched, 
                                         float[][] matchingScores) {
        List<TrackedObject> trackedList = new ArrayList<>(trackedObjects.values());
        
        // 매칭되지 않은 모든 추적 객체에 대해
        for (int i = 0; i < trackedList.size(); i++) {
            TrackedObject trackedObj = trackedList.get(i);
            
            // 이미 매칭된 객체는 건너뛰기
            if (trackedObj.getLastMatchedTime() == 0) continue;
            
            int bestMatchIdx = -1;
            float bestScore = IOU_THRESHOLD;
            
            for (int j = 0; j < detections.size(); j++) {
                if (matched[j]) continue;
                
                if (matchingScores[i][j] > bestScore) {
                    bestScore = matchingScores[i][j];
                    bestMatchIdx = j;
                }
            }
            
            if (bestMatchIdx >= 0) {
                YoloImageProcessor.Detection matchedDetection = detections.get(bestMatchIdx);
                trackedObj.update(matchedDetection);
                matched[bestMatchIdx] = true;
            } else {
                trackedObj.incrementAge();
            }
        }
    }
    
    /**
     * 새로운 탐지 객체 추가
     */
    private void addNewDetections(List<YoloImageProcessor.Detection> detections, boolean[] matched) {
        for (int i = 0; i < detections.size(); i++) {
            if (!matched[i]) {
                YoloImageProcessor.Detection detection = detections.get(i);
                
                // 신뢰도가 낮은 객체는 건너뛰기
                if (detection.getConfidence() < MIN_CONFIDENCE) continue;
                
                TrackedObject newTrackedObj = new TrackedObject(
                    nextId++,
                    detection.getLabel(),
                    detection.getConfidence(),
                    detection.getLeft(),
                    detection.getTop(),
                    detection.getRight(),
                    detection.getBottom()
                );
                trackedObjects.put(newTrackedObj.getId(), newTrackedObj);
            }
        }
    }

    /**
     * 모든 추적 객체의 나이를 증가시킴
     */
    private void increaseAge() {
        for (TrackedObject obj : trackedObjects.values()) {
            obj.incrementAge();
        }
    }

    /**
     * 지정된 최대 나이보다 오래된 객체 제거
     */
    private void removeOldObjects() {
        Iterator<Map.Entry<Integer, TrackedObject>> it = trackedObjects.entrySet().iterator();
        while (it.hasNext()) {
            TrackedObject obj = it.next().getValue();
            if (obj.getAge() > MAX_AGE) {
                Log.d(TAG, "객체 제거: ID=" + obj.getId() + ", Label=" + obj.getLabel());
                it.remove();
            }
        }
    }

    /**
     * 두 객체 간의 IoU(Intersection over Union)를 계산
     */
    private float calculateIoU(TrackedObject trackedObj, YoloImageProcessor.Detection detection) {
        // 교차 영역 계산
        float xLeft = Math.max(trackedObj.getLeft(), detection.getLeft());
        float yTop = Math.max(trackedObj.getTop(), detection.getTop());
        float xRight = Math.min(trackedObj.getRight(), detection.getRight());
        float yBottom = Math.min(trackedObj.getBottom(), detection.getBottom());

        // 교차 영역이 없으면 0 반환
        if (xRight < xLeft || yBottom < yTop) return 0;

        float intersectionArea = (xRight - xLeft) * (yBottom - yTop);

        // 각 영역 계산
        float trackedObjArea = (trackedObj.getRight() - trackedObj.getLeft()) *
                (trackedObj.getBottom() - trackedObj.getTop());
        float detectionArea = (detection.getRight() - detection.getLeft()) *
                (detection.getBottom() - detection.getTop());

        // IoU 계산
        return intersectionArea / (trackedObjArea + detectionArea - intersectionArea);
    }

    /**
     * 추적 객체 클래스 - 딥소트 알고리즘의 요소 통합
     */
    public static class TrackedObject {
        private final int id;
        private String label;
        private float confidence;
        private float left;
        private float top;
        private float right;
        private float bottom;
        private int age;
        private int hits;  // 연속적으로 매칭된 횟수

        // 속도 및 가속도 추적을 위한 필드
        private float velocityX;
        private float velocityY;
        private float accelerationX;
        private float accelerationY;
        private float prevCenterX;
        private float prevCenterY;
        private float prevVelocityX;
        private float prevVelocityY;
        private long lastMatchedTime;
        
        // 칼만 필터 관련 상태 변수 (간소화된 형태)
        private float[] state;  // [x, y, vx, vy, ax, ay]
        private float[] covariance;
        
        // 궤적 히스토리
        private LinkedList<float[]> positionHistory;

        public TrackedObject(int id, String label, float confidence,
                            float left, float top, float right, float bottom) {
            this.id = id;
            this.label = label;
            this.confidence = confidence;
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
            this.age = 0;
            this.hits = 1;
            this.lastMatchedTime = System.currentTimeMillis();
            
            this.velocityX = 0;
            this.velocityY = 0;
            this.accelerationX = 0;
            this.accelerationY = 0;
            this.prevVelocityX = 0;
            this.prevVelocityY = 0;
            this.prevCenterX = (left + right) / 2;
            this.prevCenterY = (top + bottom) / 2;
            
            // 칼만 필터 상태 초기화
            this.state = new float[6];  // [x, y, vx, vy, ax, ay]
            this.state[0] = prevCenterX;
            this.state[1] = prevCenterY;
            
            this.covariance = new float[6 * 6];
            // 간소화된 공분산 행렬 초기화 - 실제로는 더 복잡함
            for (int i = 0; i < 6; i++) {
                this.covariance[i * 6 + i] = 1.0f;  // 대각선 요소만 1.0으로 설정
            }
            
            // 위치 히스토리 초기화
            this.positionHistory = new LinkedList<>();
            this.positionHistory.add(new float[]{prevCenterX, prevCenterY});
        }

        /**
         * 새로운 탐지 결과로 추적 객체 업데이트
         */
        public void update(YoloImageProcessor.Detection detection) {
            float centerX = (detection.getLeft() + detection.getRight()) / 2;
            float centerY = (detection.getTop() + detection.getBottom()) / 2;
            
            // 현재 속도 저장
            prevVelocityX = velocityX;
            prevVelocityY = velocityY;
            
            // 속도 업데이트 (이동 평균 사용)
            velocityX = VELOCITY_WEIGHT * (centerX - prevCenterX) + (1 - VELOCITY_WEIGHT) * velocityX;
            velocityY = VELOCITY_WEIGHT * (centerY - prevCenterY) + (1 - VELOCITY_WEIGHT) * velocityY;
            
            // 가속도 업데이트
            accelerationX = ACCELERATION_WEIGHT * (velocityX - prevVelocityX) + (1 - ACCELERATION_WEIGHT) * accelerationX;
            accelerationY = ACCELERATION_WEIGHT * (velocityY - prevVelocityY) + (1 - ACCELERATION_WEIGHT) * accelerationY;
            
            // 칼만 필터 업데이트 (실제로는 더 복잡한 행렬 연산)
            if (USE_KALMAN_FILTER) {
                updateKalmanFilter(centerX, centerY);
            }

            // 객체 상태 업데이트
            this.confidence = Math.max(this.confidence, detection.getConfidence());  // 더 높은 신뢰도 유지
            this.left = detection.getLeft();
            this.top = detection.getTop();
            this.right = detection.getRight();
            this.bottom = detection.getBottom();
            
            // 중심점 저장
            this.prevCenterX = centerX;
            this.prevCenterY = centerY;
            
            // 위치 히스토리 업데이트
            addToPositionHistory(centerX, centerY);

            // 나이 초기화 및 매칭 시간 업데이트
            this.age = 0;
            this.hits++;
            this.lastMatchedTime = System.currentTimeMillis();
        }
        
        /**
         * 위치 히스토리에 새 위치 추가
         */
        private void addToPositionHistory(float x, float y) {
            positionHistory.add(new float[]{x, y});
            
            // 최대 히스토리 길이 제한
            while (positionHistory.size() > MAX_HISTORY_LENGTH) {
                positionHistory.removeFirst();
            }
        }
        
        /**
         * 칼만 필터 업데이트 (간소화된 버전)
         */
        private void updateKalmanFilter(float measuredX, float measuredY) {
            // 실제 칼만 필터는 더 복잡한 행렬 연산이 필요
            // 여기서는 개념적인 업데이트만 수행
            
            // 측정값과 예측값의 차이
            float innovationX = measuredX - state[0];
            float innovationY = measuredY - state[1];
            
            // 칼만 이득 (간소화)
            float gain = 0.7f;
            
            // 상태 업데이트
            state[0] += gain * innovationX;
            state[1] += gain * innovationY;
            state[2] = velocityX;
            state[3] = velocityY;
            state[4] = accelerationX;
            state[5] = accelerationY;
            
            // 실제 구현에서는 공분산 행렬도 업데이트
        }

        public void incrementAge() {
            this.age++;
        }

        /**
         * 모션 모델 기반 위치 예측
         */
        public void predict() {
            if (age > 0 && USE_VELOCITY_PREDICTION) {
                float width = right - left;
                float height = bottom - top;
                float dt = 1.0f;  // 프레임 간 시간 간격 (일정하다고 가정)
                
                if (USE_KALMAN_FILTER) {
                    // 칼만 필터 예측 단계 (간소화)
                    predictKalman(dt);
                    
                    // 예측된 중심점
                    float predictedCenterX = state[0];
                    float predictedCenterY = state[1];
                    
                    // 위치 업데이트
                    left = predictedCenterX - width / 2;
                    top = predictedCenterY - height / 2;
                    right = predictedCenterX + width / 2;
                    bottom = predictedCenterY + height / 2;
                    
                    // 중심점 업데이트
                    prevCenterX = predictedCenterX;
                    prevCenterY = predictedCenterY;
                } else {
                    // 기본 모션 모델 (속도 + 가속도)
                    float predictedX = prevCenterX + velocityX * dt + 0.5f * accelerationX * dt * dt;
                    float predictedY = prevCenterY + velocityY * dt + 0.5f * accelerationY * dt * dt;
                    
                    // 위치 업데이트
                    left = predictedX - width / 2;
                    top = predictedY - height / 2;
                    right = predictedX + width / 2;
                    bottom = predictedY + height / 2;
                    
                    // 중심점 업데이트
                    prevCenterX = predictedX;
                    prevCenterY = predictedY;
                }
            }
        }
        
        /**
         * 칼만 필터 예측 단계 (간소화된 버전)
         */
        private void predictKalman(float dt) {
            // 상태 전이 (간소화)
            // x = x + vx*dt + 0.5*ax*dt^2
            // y = y + vy*dt + 0.5*ay*dt^2
            // vx = vx + ax*dt
            // vy = vy + ay*dt
            
            state[0] = state[0] + state[2] * dt + 0.5f * state[4] * dt * dt;
            state[1] = state[1] + state[3] * dt + 0.5f * state[5] * dt * dt;
            state[2] = state[2] + state[4] * dt;
            state[3] = state[3] + state[5] * dt;
            
            // 실제 구현에서는 공분산 행렬도 업데이트
        }

        // Getters
        public int getId() { return id; }
        public String getLabel() { return label; }
        public float getConfidence() { return confidence; }
        public float getLeft() { return left; }
        public float getTop() { return top; }
        public float getRight() { return right; }
        public float getBottom() { return bottom; }
        public int getAge() { return age; }
        public int getHits() { return hits; }
        public long getLastMatchedTime() { return lastMatchedTime; }
        public List<float[]> getPositionHistory() { return positionHistory; }
        public int getHistoryLength() { return positionHistory.size(); }
        
        @Override
        public String toString() {
            return id + ": " + label + " (" + String.format("%.2f", confidence * 100) + "%), age=" + age + ", hits=" + hits;
        }
    }
}